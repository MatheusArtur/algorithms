#+STARTUP: overview
#+TITLE: Data Structures
#+CREATOR: Matheus Costa (macc)
* Linked lists - Intro
** What are data structures?

A good data structure would be an array. But,

# Advantages of array:
Being so easy-to-use and intuitive.

# Disvantages of array
A shitfest to realloc and becomes pretty couter-intuitive for complex use.

# Acessing non-valid positions
In C, it gets a n from memory.
In other languages like java, it warns.

** Linked Lists

# Pointers are used to link each node of our list

fa -> fb -> nil

where fX is the guy, and arrow is the pointer.

# Versatility

The liked list is powerful. It can easily be resized, just point it to (eg; ff) instead of nil.

# Why?

It can be used to write specifically FREE-Memory instead of overwriting it.

# How?
Try this C code, look how it recursively the structure is called with a pointer. It has a structure with a item and a pointer to a new structure.
 #+BEGIN_SRC c
   #include <stdio.h>

   struct node{
     int item;
     node *next;
   }

   int main(void){
     return 0;
   }
 #+END_SRC

** Applying create, add, search and many other functions in linked list.
*** Creating elements
#+BEGIN_SRC c
  node* create_liked_list(){
    return NULL;
  }
#+END_SRC
*** Adding elements
#+BEGIN_SRC c
 node* add(node *head, int item){
    node *new_mode = (node*) malloc(sizeof(node));
    new_node->item = item;
    new_node->next = head;
    return new_node;
  }
#+END_SRC
*** Search function
#+BEGIN_SRC c
  node* search(node *head, int item){
    while(*head != NULL){
      if(*head->item == item){
        return *head;
      }
      head = head->next;
    }
      return NULL;    
  }
#+END_SRC
*** Remove function
# This is a tricky one, you'll need to use a pointer to save the previous position and point it to the current->next
#+BEGIN_SRC c
//TODO
#+END_SRC
** Void, and fuction as a pointer
Well, instead of having for example, a integer and a pointer, you have a pointer to another list (structure) of passagers, students, whatever..
|----------+-----+----------+-----+----------+-----|
| 2        | ->  | 5        | ->  | 9        | ->  |
|----------+-----+----------+-----+----------+-----|
| *bellow* | ->  | *bellow* | ->  | *bellow* | ->  |
| passager | nil | passager | nil | passager | nil |
|----------+-----+----------+-----+----------+-----|

*** Void can point to almost everything!
This can be pretty useful to change and reutilize the code.
#+BEGIN_SRC c
  struct node{
    void* item;
    node* next;
  }
#+END_SRC

# But notice: In algorithims like the search one, you cannot check (*void == (void)item), so you'll be making a specific search function and pass it with an pointer.
So, lets create a universal search function.
#+BEGIN_SRC c
// TODO
node* search(node *head, void item){
  while(*head != NULL){
    if(*head->item == item){
      return *head;
    }
    head = head->next;
  }
    return NULL;    
}
//TODO
#+END_SRC
* Stack
# Context
  For dennying acess 


# "LIFO" - Last In, First Out.
  LIFO consists in tree main operations:

  - =Push=, adds a element to the stack top
  - =Pop=, removes the stack top element
  - =Peek=, shows the stack top element


** Creating a Stack

#+BEGIN_SRC c
  #define MAX_STACK_SIZE 10

  struct stack{
    int current_size;
    int items(MAX_STACK_SIZE);
  };

  stack* create_stack(){
    stack *new_stack = (stack*) malloc(sizeof(stack));
    new_stack -> current_size = 0;
    return new_stack;
  }
#+END_SRC

** PUSH function

#+BEGIN_SRC c
  void push(stack *stack, int item){
    if(stack->current_size == MAX_STACK_SIZE){
      printf("Stack Overflow\n");
    }
    else{
      stack->items[stack->current_size++] = item; ++ -- 
    }
  }
#+END_SRC

*** Stack with lists and PUSH function

    Note how the =push= above and =push_list= have similar headers due to abstractions.
#+BEGIN_SRC c
  struct *node{
    int item;
    node *next;
  }

  struct stack{
    node *top
  }

  stack* create_stack(){
    stack *new_stack = (stack*) malloc(sizeof(stack));
    new_stack->top = NULL;
    return new_stack;
  }
    
  void push_list(stack *stack, int item){
    node *new_top = (node*) malloc(sizeof(node));
    new_top->item = item;
    new_top->next = stack->top;
    stack->top = new_top;
  }
#+END_SRC

** POP Function
#+BEGIN_SRC c
  int pop(stack *stack){
    if(is_empty(stack)){
      printf("Stack underflow\n");
      return -1;
    }
    else{
      return stack->items[--stack->current_size];
    }
  }

  int peek(stack *stack){
    if(is_empty(stack)){
      printf("Stack underflow\n");
      return -1;
    }
    else{
      return stack->items[stack->current_size - 1];
    }
  }
#+END_SRC
